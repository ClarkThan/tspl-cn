## 第3章 更进一步

通过前面一章，你可以用一套很小的元语法结构和过程编写出 Scheme 程序。这一章介绍了一些附加特性，可以让你写出更复杂，更有效率的程序来。

###3.1 语法扩展

在2.5节我们说过，`let`只不过是一个`lambda`表达式的句法扩展。现在，你可能想知道哪一个是核心语法形式，而哪一个是语法扩展，以及，如何定义新的语法扩展。

事实上，我们没必要明确区分核心语法与扩展语法的区别，因为，一旦定义了一个扩展语法，它就和核心语法形式是相同的地位。分清它们之间的区别只是让理解语言本身更容易。

核语法形式包括 top-level define，常量，变量，过程调用，引用，lambda 表达式，if 表达式以及 set!表达式。

```
<程序>			--> <形式>*
<形式>			--> <定义> | <表达式>
<定义>			--> <变量定义> | (begin <变量定义>*)
<变量定义> 		--> (define <变量> <表达式>)
<表达式>			--> <常量>
			 |  <变量>
			 |  (quote <datum>)
			 |  (lambda <形参> <表达式> <表达式>*)
			 |  (if <表达式> <表达式> <表达式>)
			 |  (set! <变量> <表达式>)
			 |  <过程调用>
<常量>			--> <布尔值> | <数字> | <字符> | <字符串>
<形参>			--> <变量>
			 |  (<变量>*)
			 |  (<变量> <变量>* . <变量>)
<过程调用>		--> (<表达式> <表达式>*)
```

上面的语法表是模棱两可的，过程调用的语法与lambda, if, 以及 set! 表达式互相冲突。为了有资格作为一个过程被调用，第一个表达式不得是这些关键字之一，除非该关键字已经被重新定义或者被绑定为本地变量。

[注]与 lambda 似乎并不冲突，`((lambda ...) 实参)` 这样的调用是合法的，而`((quote xxx) ...)`则是真的冲突了。常量(字面量)也不能作为过程被调用，if 表达式倒是可以通过不同的分支判断返回不同的过程加以调用。

2.6 节介绍的 defun（Lisp's defun） 语法并没有包含在核心语法中，Lisp 的 defun 语法更为清楚和直接。类似地，在核心语法定义中，if 表达式不允许省略"否则"子句。一个单分支的 if 表达式可以很容易地用任意的常量（比如 #f) 来代替缺失的 "否则" 子句，从而翻译成核语法所接受的表达式。

let 可以这样被定义

```
(define-syntax let
  (syntax-rules ()
    ((_ ((x v) ...) e1 e2 ...)
     ((lambda (x ...) e1 e2 ...) v ...))))
```


CPS

正如我们在上一节中所讨论的，延续等待每个表达式的值。特别是，延续与每个过程调用相关联。当一个过程通过非尾调用调用了另一个过程，被调用的过程接收一个隐含的延续，它负责完成主调过程最后剩下的body，并且将结果返回给主调过程的延续。如果调用是一个尾调用，被调过程只需接收主调过程的延续。