# 3.1 句法扩展（宏）

就象我们在[2.5节](../chapter02/2-5.md)看到的一样，`let`句法形式本质上是通过`lambda`表达式及过程应用定义出来的一个句法扩展，`lambda` 表达式以及过程应用两者都属于核心语法形式。在这一点上，你可能想知道哪些句法形式是核心语法，哪些是宏，以及怎样定义新的宏。本节提供这些问题的一些答案。

事实上，我们没有必要明显地区分核心语法与宏，因为宏一旦定义，就具有了与核心语法相同的地位。然而这里对它们进行区分，是为了更容易理解语言本身，因为它允许我们将注意力集中在核心语法上，并以此为基础进一步理解其它的方面。


一个 Scheme 实现需要区分核心形式和宏。作为编译或解释执行的第一步，Scheme 实现首先将宏展开成为核心语法形式，接下来只需要关注核心语法形式的解释或编译。语言标准并未定义哪一个语法形式应该实现为核心语法，那一个语法形式应该实现为宏，所以，这里讨论的核心语法是与实现相关的，在不同的实现中可能会与这里描述的不一样。（译注：这一段并未尊重原著，我觉得用宏来代替句法扩展并无不妥，还更好理解）

语言的核心语法里具体应该包含哪些东西是有争议的，应该足以通过核心语法扩展出其它所有的语法形式。这里讨论的集合是满足这一约束条件的最简单的集合。（也就是说，一整个完整的语言都可以通过这里描述的这个小子集实现出来）


核心语法里包括顶级定义`define`，常量，变量，过程应用（函数调用），`quote`表达式，`lambda`表达式，`if`表达式, 以及`set!`表达式。下面的语法表描述了这些定义和表达式。在语法表里，竖线(|)表示单选，一个语法形式后面跟着星号(*)表示该形式的零个或多个。<variable>可以是任何 Scheme 标识符。<datum>可以是任何 Scheme 对象，例如一个数字，一个列表，一个符号或者一个向量。<boolean> 是 #t 或 #f 之一，<number> 可以是任何数字，<character>可以是任意字符，<string> 可以是任意字符串。我们已经见过数字，字符串，列表，符号以及布尔值的例子了。有关这些对象和其他对象的对象级语法的更多信息，请参阅[第六章](../chapter06/README.md)或[语法描述]()。

```
<program>               -->	<form>*
<form>                  -->	<definition> | <expression>
<definition>            -->	<variable definition> | (begin <definition>*)  
<variable definition>   -->	(define <variable> <expression>)
<expression>	        -->	<constant>
                         |	<variable>  
                         |	(quote <datum>)  
                         |	(lambda <formals> <expression> <expression>*)  
                         |	(if <expression> <expression> <expression>)  
                         |	(set! <variable> <expression>)  
                         |	<application>  
<constant>              -->	<boolean> | <number> | <character> | <string>  
<formals>               -->	<variable>
                         |	(<variable>*)  
                         |	(<variable> <variable>* . <variable>)  
<application>           -->	(<expression> <expression>*)
```

上面的语法表其实是含糊不清的，因为过程应用的语法与 `quote`, `lambda`, `if`, 以及 `set!` 表达式相冲突。为了有资格作为一个过程(函数)被调用，至少在最先的`<expression>`里，不能包含 quote，lambda, if, 以及 set! 等关键字。除非这些关键字已经被重新定义过，或者处于一个局部绑定中。

[译注]这里不是很理解，lambda 表达式应该是不冲突的`((lambda (形参) ...) 实参)`显然是合法的过程调用，`if`也有可能是合法的，它可以根据条件返回不同的函数对象嘛。`quote`表达式倒是真的冲突了，`((quote ...) arg)`显示不是合法的表达式. `set!`似乎也冲突，set! 的返回值好象是未定义，那就不能把 set! 表达式放在括号后面当作函数来调用了。

[2.6节](../chapter02/2-6.md)给出的`defun`语法并未包含在核心语法当中（那是 Lisp 的语法），类似地，`if`语法不允许省略 else 子句，但是当一个 if 表达式缺失了 else 子句的时候，只要用任意的表达式（比如 #f）来顶替缺失的子句，就能转换为符合核心语法规定的 if 表达式. [译注]在这一点上，几乎所有的 Scheme 实现都允许省略 else 子表达式，倒是 Racket 这个不是 Scheme 的 Scheme，它的 else 子表达式是不能省略的。


