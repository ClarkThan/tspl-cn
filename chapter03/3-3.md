# 3.3 Continuations(延续)

对每一个 Scheme 表达式进行求值时，Scheme 实现必须对两件事保持跟踪：(1)求值的对象;(2)如何处理结果。思考下面的表达式中`(null? x)`的求值

    (if (null? x) (quote ()) (cdr x))
    
Scheme 实现首先对`(null? x)`进行求值，然后以该结果为基础，再来决定对`(quote ())`或者`(cdr x)`进行求值。在这里，“求值的对象”是`(null? x)`，“怎么处理结果”就是决定对`(quote ())`和`(cdr x)`两者的其中之一进行求值。我们把"如何处理结果"称之作计算的延续(continuations).

因此，求值任何表达式的任何一个点上，都有一个延续存在，接下来要么完成计算，要么继续计算。我们假设`x`的值是`(a b c)`，在求值`(if (null? x) (quote ()) (cdr x))`的过程中，我们可以分解出6个延续，它们正在等待下面的值：

1. `(if (null? x) (quote ()) (cdr x))`的值
2. `(null? x)` 的值
3. `null?` 的值
4. `x` 的值
5. `cdr` 的值
6. 再一次, `x`的值

`(cdr x)`的延续并没有列出来，因为它与正在等待`(if (null? x) (quote ()) (cdr x))`的延续是同一个。

Scheme 允许使用函数（过程） `call/cc`（call-with-current-continuation）来捕获任意表达式的延续。`call/cc`有一个参数`p`，`p`必须是一个函数。`call/cc`将当前延续构造为一个对象实体，然传递给`p`。而延续本身表现为一个函数`k`。每当`k`应用到某个值上，它就将该值返回到`call/cc`当初捕获延续的地方。[译注]行为表现上就是乘着时光机器回到了过去，在那里有一个延续等待某个值进行下一步计算，然而它得到的值是你传递给`k`的值，而不是原本应该得到的值。大约可以这样理解：`call/cc`相当于调试程序时，在某个地方下个断点，执行到该点时，你人为干预程序的执行修改了某个变量的值，接下来的结果就不一样了。

如果`p`在不调用`k`的情况下返回，则该过程（函数）返回的值将成为应用`call/cc`的值。

思考下面简单的例子：

```
(call/cc
  (lambda (k)
    (* 5 4))) => 20
    
(call/cc
  (lambda (k)
    (* 5 (k 4)))) => 4
    
(+ 2
   (call/cc
     (lambda (k)
       (* 5 (k 4))))) => 6
```


