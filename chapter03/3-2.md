# 3.2 更多的递归

在[2.8节](../chapter02/2-8.md)中，我们已经看到了如何使用 `define` 定义一个递归函数。在那之前，我还看到了使用`let`将一个函数绑定到一个局部变量上。很自然，我们可能想知道，用`let`绑定的局部函数是否可以递归调用？答案是否定的，至少是不直观的方法。如果你尝试求值下面的表达式

```
(let ([sum (lambda (ls)
             (if (null? ls)
                 0
                 (+ (car ls) (sum (cdr ls)))))])
  (sum '(1 2 3 4 5)))
```

很可能会遇到一个提示告诉你`sum`未定义。这是因为变量`sum`仅仅在`let`表达式的 body 中可见，而 `lambda`表达式并不是 body 的一部分，我们可以把 `sum` 作为参数传递给它自己，来绕过这个限制。

```
(let ([sum (lambda (sum ls)
             (if (null? ls)
                 0
                 (+ (car ls) (sum sum (cdr ls)))))])
  (sum sum '(1 2 3 4 5))) => 15 
```

这是个聪明的做法，但是有一个更简单的办法，那就是`letrec`。和`let`类似，`letrec`包含了一些'变量-值'对，其 body 由一系列表达式构成

```
(letrec ((var expr) ...) body1 body2 ...)
```

但是和 `let`不同的是，`var ...`等变量并不仅仅在 body 中可见，它在所有的 `expr ...` 表达式中也是可见的，这样，我们就重写上面的表达式：

```
(letrec ([sum (lambda (ls)
                (if (null? ls)
                    0
                    (+ (car ls) (sum (cdr ls)))))])
  (sum '(1 2 3 4 5))) => 15
```

我们可以使用`letrec`定义出互相递归调用的函数来，比如函数 `even?`以及`odd?`，这是练习 2.8.6 的主题。

```
(letrec ([even?
          (lambda (x)
            (or (= x 0)
                (odd? (- x 1))))]
         [odd?
          (lambda (x)
            (and (not (= x 0))
                 (even? (- x 1))))])
  (list (even? 20) (odd? 20))) => (#t #f)
```

在`letrec`表达式里，`expr ...`系列子表达式通常是 `lambda`表达式，虽然并不总是这样。该表达式必须遵守的一个限制是，对每一个 `expr`的求值不能依赖任何变量 `var ...` 的求值。如果`expr`都是`lambda`表达式的话，总是可以满足这个限制，因为尽管某个 `var`变量在 `lambda`表达式中被引用，但是直到`lambda`表达式生成的函数在`letrec`的 body 中被调用，被引用的 `var`才需要被求值。下面的 `letrec`表达式满足此限制。

```
(letrec ([f (lambda () (+ x 2))]
         [x 1])
  (f)) => 3
```

但是下面的并不满足

```
(letrec ([y (+ x 2)]
         [x 1])
  y)
```

在这种情况下，会抛出一个异常，提示`x`未定义。

我们可以通过 `letrec` 来隐藏功能单一的助手函数，这样就不必要将它们都定义为顶级（全局）函数，从而避免混淆全局命名空间。这一点可以由下面的`list?`函数来证明, which follows the "hare and tortoise" algorithm outlined in Exercise 2.9.8. 

```
(define list?
  (lambda (x)
    (letrec ([race
              (lambda (h t)
                (if (pair? h)
                    (let ([h (cdr h)])
                      (if (pair? h)
                          (and (not (eq? h t))
                               (race (cdr h) (cdr t)))
                          (null? h)))
                    (null? h)))])
      (race x x))))
```

如上例所示，当递归函数仅仅在函数外部的一个地方被调用时，使用另一种称为"命名的let"来写往往更加清晰。Named let 表达式的形式如下：

```
(let name ((var expr) ...)
  body1 body2 ...)
```

命名的 let 和未命名的 let 类似，它将每一个变量 `var ...` 绑定到每一个值`expr ...`，每一个变量的作用域是 let 表达式的 body，每一个 `var` 仅仅在 body 内部可见，在其它的 `expr ...`里是不可见的。此外，变量`name`在 body 内部被绑定为一个可以递归调用的函数，该函数的参数就是每一个 `var ...`的新值。

下面是用 Named let 重写的 `list?` 函数

```
(define list?
  (lambda (x)
    (let race ([h x] [t x])
      (if (pair? h)
          (let ([h (cdr h)])
            (if (pair? h)
                (and (not (eq? h t))
                     (race (cdr h) (cdr t)))
                (null? h)))
          (null? h)))))
```

就像普通的`let`表达式可以表示为将`lambda`表达式直接应用到参数上一样，Named let 表达式也可以表示为对参数的递归过程的应用。一个 Named let 的形式

```
(let name ((var expr) ...)
  body1 body2 ...)
```

可以用`letrec`重写为

```
((letrec ((name (lambda (var ...) body1 body2 ...)))
   name)
 expr ...)
```

或者重写为

```
(letrec ((name (lambda (var ...) body1 body2 ...)))
  (name expr ...))
```

provided that the variable name does not appear free within `expr ....` 

