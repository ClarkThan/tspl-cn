# 3.2 更多的递归

在[2.8节](../chapter02/2-8.md)中，我们已经看到了如何使用 `define` 定义一个递归函数。在那之前，我还看到了使用`let`将一个函数绑定到一个局部变量上。很自然，我们可能想知道，用`let`绑定的局部函数是否可以递归调用？答案是否定的，至少是不直观的方法。如果你尝试求值下面的表达式

```
(let ([sum (lambda (ls)
             (if (null? ls)
                 0
                 (+ (car ls) (sum (cdr ls)))))])
  (sum '(1 2 3 4 5)))
```

很可能会遇到一个提示告诉你`sum`未定义。这是因为变量`sum`仅仅在`let`表达式的 body 中可见，而 `lambda`表达式并不是 body 的一部分，我们可以把 `sum` 作为参数传递给它自己，来绕过这个限制。

```
(let ([sum (lambda (sum ls)
             (if (null? ls)
                 0
                 (+ (car ls) (sum sum (cdr ls)))))])
  (sum sum '(1 2 3 4 5))) => 15 
```

这是个聪明的做法，但是有一个更简单的办法，那就是`letrec`。和`let`类似，`letrec`包含了一些'变量-值'对，其 body 由一系列表达式构成

```
(letrec ((var expr) ...) body1 body2 ...)
```

但是和 `let`不同的是，`var ...`等变量并不仅仅在 body 中可见，它在所有的 `expr ...` 表达式中也是可见的，这样，我们就重写上面的表达式：

```
(letrec ([sum (lambda (ls)
                (if (null? ls)
                    0
                    (+ (car ls) (sum (cdr ls)))))])
  (sum '(1 2 3 4 5))) => 15
```

我们可以使用`letrec`定义出互相递归调用的函数来，比如函数 `even?`以及`odd?`

